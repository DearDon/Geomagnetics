该程序从2012／1／11开始着手编写
by don

log1(2012/1/11):
	今天开始编写程序的总体框架，写了一个小的主程序，主要着手写共轭梯度的子例程，一口气将基本算法写完，然后想起昨天与黄讨论的各自子例程里的变量会不会相互影响，于是又写了个试验程序，结果证明我的想法是错的，即使是参数可传递的子例程里的变量也只有在参数中的才可传递，内部其它变量是不会传递出去的。最后，我将写好的程序进行编译，不出所料，错误提示有两大页，留到以后解决，今天到此为止。

log2(2012/1/13):
	今天着手解决上次留下的各种程序错误，先解决语法错误，逻辑错误等语法错误完成后才能查找。经分析，主要错误来自矩阵乘法，经过查资料，通过内部函数解决了二维矩阵相乘以及个人编写子程序解决一维矩阵相乘，二维与一维相乘还没解决，今天到此为止。

log3(2012/1/15):
	现在火车上，本想无聊时解决二维与一维矩阵的混乘问题，结果发现低估了程序问题了，除了二维与一维相乘需要去验证内部函数使用对错上，那个一维与一维的相乘也出现了问题，总之得再写入新的子程序。

log4(2012/1/16):
	今天回老家辞年，在老家继续研究矩阵乘法，经过多次实验，发现matmul这个内部函数并不能进行一维矩阵的乘法，至少其中有个二维矩阵。所以，二维与二维的相乘及二维与一维的相乘它都可以直接实现，并且对矩阵的赋值和输出(write(*,*)q)都是列优先，即先输出（入）一列再输另一列，当然直接指定行列输出入就不会影响，

log5(2012/3/2):
	现在已经回到学校并开学了，这是新学期第一次继续这个问题，仍旧研究矩阵相乘问题，发现太久没编对于矩阵的规则又很陌生了，于是觉得还是应该了解到什么尽快做下笔记。今天弄清楚了矩阵相乘的规则到底是怎么样的，matmul这个内部函数能解决二维与一维及二维与二维的矩阵乘法，但不能解决一维与一维的乘法。由上一篇log我们知道赋值和输出都是列优先，这样我们便能把输入的数和我们日常数学中的矩阵的分量对应起来,如对于A(2,2),B(2,2),b(2),data A/1,0,1,1/其中0表示数学矩阵中元素A(2,1)，注意一定不要把元素弄混，以下我们的说明都是按照我们数学中矩阵的排序来说的。首先，对于二维与一维相乘，matmul(A,b)表示矩阵A与列向量b相乘，matmul(b,A)则表示行向量b与矩阵A相乘，b自动转置；然后是二维与二维相乘问题，它与数学中的矩阵相乘完全一样，其中要注意的就是计算机中是不分行向量与列向量的（因为它们在计算机中本质都是一维数组），只有二维数组用matmul时才有矩阵的概念，若矩阵是左乘则表示它的每一行与后面的相应乘再求和，右乘则相反，这与数学中矩阵乘法是完全一致的，需要注意的地方就是赋值与输出中元素与数学矩阵中元素的对应。

log6(2012/4/28):
	共轭梯度的子例程已经没问题了，现在着手编写由观测数据推出法方程的步骤。经过一天努力，把由数据得到观测方程和法方程的框架写出来了，并编译通过，但是对观测方程，有一项为0，为列满秩，要去掉该列。但是问题是法方程最后一列值不定，表示最后一列的计算有问题（用N_max=1试过），猜想是grad_p的问题，留给下次解决。

log7(2012/5/5):
	经过仔细检查，问题是由于算最后一列时用到了一个未定义的变量，所以较好的习惯是用上implicit none语句，所有变量先定义再用比较保险，两次遇见该问题了，且都不易查出，要仔细一行一行看才能发现。现在可得到无全0列的观测方程，但是用它反演计算时发现它得出的系数gh是NaN.下次再解决该问题。

lon8(2012/5/5):
	一大早起来检查，发现了共轭梯度子例程不能求解的问题，共轭梯度法要求系数矩阵是对称正定的，而我想当然的让系矩为方阵，并没化成对称形式便开始解了，该问题解决，但是用1阶的数据正算后反算，得出的结果对于g(1)以上项误差总是挺大

log9(2012/5/12):
	昨天考完试，今天有空来继续完成程序问题了，首先对于g(1)以上误差太大是因为赋值给lon变量的错误，因g(1)与lon无关，所以影响较小。解决了该问题后，继续测试，发现当共轭法取误差范围为0.001等值时仍不能得到较好结果，跟踪变量后发现所有变量都没问题，于是怀疑共轭法子程序有问题。经过单独的检查，才发现，原来要使误差范围取很小如0.000000000000000000001这种才能得到收敛很好的结果。然后程序一阶内符合好像没问题了。准备让N到达10阶，进行检验.

log10(2012/5/27):
	在网上找到一个FORTRAN版的IGRF，本以为能在LINUX下分析程序加上GDB就会很轻松了，但这个老版的FORTRAN里GOTO等不习惯的东西太多了，可读性不好，仍旧分析不出为什么自己的正演程序结果与IGRF的不一样，经过一天的挣扎，目标定在了FORTRAN源程序里的1021行的非结构块DO，整个计算的核心就在这了，找时间把这弄明白相信就应该能找到问题所在了。

log11(2012/6/24):
	放弃之前用IGRF源程序改写人想法（太复杂，很多旧版本人语法看不懂），着手检查自己人程序为什么和IGRF的计算结果不同，选定某特定点(30,30)的特定分量，进行一阶一阶渐渐计算如下
试验正演程序：
1 degree:perfect
mine:
 x   26337.198924584838     
 y  -5605.7333328586747     
 z   27865.266667141332     
 T   38749.779093862890
IGRF:
X =   26337 nT          SV =     898 nT/yr
               Y =   -5606 nT          SV =    1399 nT/yr
               Z =   27865 nT          SV =     378 nT/yr
               F =   38750 nT          SV =     680 nT/yr
2 DEGREE:terrible
it prove that legendre function have something wrong,
研究发现该子程序块里错误是由（2*m-1)/(2*m)引起，由于m为整数，
计算机将其结果当为0，并不是我们想要人当m＝2时人0.75
算至二阶后已经发现问题，并将其改正不，此时计算二阶误差在小数点之后，但是计算十阶时误差最大可达10几NT，个人认为是IGRF只保留整数位，精度太小所致（因为2阶是差开0.5左右，10阶时加项过多，每项相差0.1也能累积到很大误差）。
此时的目标是：
用改过的程序进行反演人源数据计算，看内符合如何，但是结果不尽人意，哪怕是用自己写的正演程序进行2阶反演也不行，由之前人经验，一定是反演程序法方程有问题，使得在正演程序基础上写的反演程序与之不相配。现在头绪很乱，下次继续进行改进。

log12(2012/6/25):
	今天接着昨天的工作，对自己的正演程序与IGRF的进行对比，一阶阶人试验过程中发现5阶以下的正演都没问题，但第5阶明显有差异，查看IGRF系数时发现原来是在写地物专题论文时将第5阶系数自增了10，忘改回来了。改了后发现正演程序与IGRF不管是一阶还是整个10阶之和正演对比误差都小于0.5（多神奇的事，故log11所猜的10阶误差来自各阶的累积是错的）。纠结了这么久的错误又是来自自己的粗心，再次说明了文件的分类与说明的重要性。
	目前，自己的正演程序已确定与IGRF相符了（注意自己的程序输入经纬度与IGRF的顺序相反）。进行反演时发现只反演一阶的系数很顺利，但当NMAX＝2时，结果便不再好了，试验发现，二阶系数中有两个系数随着要求精度的变化共同变化，其它系数则较稳定，
说明它们是相关的，也许满足不了矩阵满秩，猜想应该是最小二乘中没有取估值的原因。留给下次。

log13(2012/6/26):
	继续昨天的工作，昨天下机后思考了一会，由于上次已经发现有两个系数好像有相关性，于是研究是不是原系数矩阵相关所致，再一思考，发现原来开始的时候为了方便，将坐标点取值都相同了，一定是这样导致的相关性，于是将坐标取为不同开始试验。
二阶时：
非常成功，能无误差发反演出所有的系数。
直接十阶试验：
使用６４００个数据点，结果不尽人意；
准备全球一度的数据点计算，共计６００００多个，结果完全符合，说明了反演数据密度的重要性，这个反演程序基本完成了，余下的就是加以修饰等。历时半年之久的程序终于成功了。心情非常愉快。
	本想让程序更人性化，但发现由于不熟悉f77,心有余而力不足。。。就这样吧。

log14(2014/1/13):
	这次记录离上次跨度很大，差不多两年了。虽然程序没有发现问题，但是两年后的今天使用时纠结了很久，因为基本忘了这个程序该怎么用了，尝试了好几次，差点还重看代码了。好不容易弄清楚，现在好好记下用法。
	首先完整的程序由main.f sub.f sub1.f组成。编译时先用gfortran -c sub.f 类似编好三个源文件（PS：要先编译子文件，再编主文件，因为主文件要调用子文件）最后用第一步得到的三个.o文件用gfrotran -o main main.o sub.o sub1.o 得到最终的可执行文件main。运行时要求在招待目录下存在一个数据文件data，data里要求每行对应一个X分量观测数（该反演只考虑了X分量，其它分量没做），data的每一行由一个观测点的经度、纬度、X分量大小构成，相互用空格空开，不同观测点位于不同行。准备好这些数据后就可以运行./main，最后屏幕上会输出13阶的高斯系数（虽然自己试做时做的10阶，但是考虑到之后IGRF模型已经变为13阶了，所以有可能会做到包含13阶的模型，程序写到了13阶，毕竟高阶模型将超过10阶的系数设为0是可以包含低阶模型的）。GOOD LUCK！
